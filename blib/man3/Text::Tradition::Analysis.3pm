.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Tradition::Analysis 3"
.TH Text::Tradition::Analysis 3 "2013-08-10" "perl v5.16.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Tradition::Analysis \- functions for stemma analysis of a tradition
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::Tradition is a library for representation and analysis of collated
texts, particularly medieval ones.  Where the Collation is the central
feature of a Tradition, it may also have one or more stemmata associated
with it, and these stemmata may be analyzed. This package provides the
following modules:
.IP "\(bu" 4
Text::Tradition::HasStemma \- a role that will be composed into
Text::Tradition objects, providing the ability for Text::Tradition::Stemma
objects to be associated with them.
.IP "\(bu" 4
Text::Tradition::Stemma \- an object class that represents stemma
hypotheses, both rooted (with a single archetype) and unrooted (e.g.
phylogenetic trees).
.IP "\(bu" 4
Text::Tradition::Analysis (this package). Provides functions for
the analysis of a given stemma against the collation within a given
Tradition.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  use Text::Tradition;
\&  use Text::Tradition::Analysis qw/ run_analysis analyze_variant_location /;
\&  my $t = Text::Tradition\->new( 
\&    \*(Aqname\*(Aq => \*(Aqthis is a text\*(Aq,
\&    \*(Aqinput\*(Aq => \*(AqTEI\*(Aq,
\&    \*(Aqfile\*(Aq => \*(Aq/path/to/tei_parallel_seg_file.xml\*(Aq );
\&  $t\->add_stemma( \*(Aqdotfile\*(Aq => $stemmafile );
\&
\&  my $variant_data = run_analysis( $tradition );
.Ve
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.ie n .SS "run_analysis( $tradition, %opts )"
.el .SS "run_analysis( \f(CW$tradition\fP, \f(CW%opts\fP )"
.IX Subsection "run_analysis( $tradition, %opts )"
Runs the analysis described in analyze_variant_location on every location in the 
collation of the given tradition, with the given options. These include:
.IP "\(bu" 4
stemma_id \- Specify which of the tradition's stemmata to use. Default
is 0 (i.e. the first).
.IP "\(bu" 4
ranks \- Specify a list of location ranks to analyze; exclude the rest.
.IP "\(bu" 4
merge_types \- Specify a list of relationship types, where related readings 
should be treated as identical for the purposes of analysis.
.IP "\(bu" 4
exclude_type1 \- Exclude those ranks whose groupings have only type\-1 variants.
.ie n .SS "group_variants( $tradition, $rank, $lacunose, $transposed, $merge_relationship_types )"
.el .SS "group_variants( \f(CW$tradition\fP, \f(CW$rank\fP, \f(CW$lacunose\fP, \f(CW$transposed\fP, \f(CW$merge_relationship_types\fP )"
.IX Subsection "group_variants( $tradition, $rank, $lacunose, $transposed, $merge_relationship_types )"
Groups the variants at the given \f(CW$rank\fR of the collation, treating any
relationships in the set \f(CW$merge_relationship_types\fR as equivalent. 
\&\f(CW$lacunose\fR should be a reference to an array, to which the sigla of lacunose
witnesses at this rank will be appended; \f(CW$transposed\fR should be a reference
to a hash, wherein the identities of transposed readings and their
relatives will be stored.
.PP
Returns a hash \f(CW$group_readings\fR where \f(CW$rdg\fR is attested by the witnesses listed 
in \f(CW$group_readings\fR\->{$rdg}.
.ie n .SS "solve_variants( $calcdir, @groups )"
.el .SS "solve_variants( \f(CW$calcdir\fP, \f(CW@groups\fP )"
.IX Subsection "solve_variants( $calcdir, @groups )"
Looks up the set of groups in the answers provided by the external graph solver 
service and returns a cleaned-up answer, adding the rank IDs back where they belong.
.PP
The answer has the form 
  { \*(L"variants\*(R" => [ array of variant location structures ],
    \*(L"variant_count\*(R" => total,
    \*(L"conflict_count\*(R" => number of conflicts detected,
    \*(L"genealogical_count\*(R" => number of solutions found }
.ie n .SS "analyze_location ( $tradition, $graph, $location_hash )"
.el .SS "analyze_location ( \f(CW$tradition\fP, \f(CW$graph\fP, \f(CW$location_hash\fP )"
.IX Subsection "analyze_location ( $tradition, $graph, $location_hash )"
Given the tradition, its stemma graph, and the solution from the graph solver,
work out the rest of the information we want.  For each reading we need missing, 
conflict, reading_parents, independent_occurrence, followed, not_followed,
and follow_unknown.  Alters the location_hash in place.
.ie n .SS "similar( $word1, $word2 )"
.el .SS "similar( \f(CW$word1\fP, \f(CW$word2\fP )"
.IX Subsection "similar( $word1, $word2 )"
Use Algorithm::Diff to get a sense of how close the words are to each other.
This will hopefully handle substitutions a bit more nicely than Levenshtein.
.ie n .SS "wit_stringify( $groups )"
.el .SS "wit_stringify( \f(CW$groups\fP )"
.IX Subsection "wit_stringify( $groups )"
Takes an array of witness groupings and produces a string like
['A','B'] / ['C','D','E'] / ['F']
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software and is provided \*(L"as is\*(R" without express
or implied warranty.  You can redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tara L Andrews <aurum@cpan.org>
