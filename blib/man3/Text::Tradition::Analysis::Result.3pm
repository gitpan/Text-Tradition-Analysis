.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Tradition::Analysis::Result 3"
.TH Text::Tradition::Analysis::Result 3 "2012-09-16" "perl v5.16.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Tradition::Analysis::Result \- object to express an IDP calculation result
for a particular graph problem.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Given a graph (expressing a stemma hypothesis) and a set of witness groupings 
(expressing variation in reading between witnesses related according to the
stemma hypothesis), it is possible to calculate certain properties of how the
readings might be related to each other. This calculation depends on a custom
program run under the \s-1IDP\s0 system [\s-1TODO\s0 \s-1URL\s0]. As the problem is NP-hard, the
calculation can take a long time. The purpose of this object is to allow storage
of calculated results in a database.
.PP
For each graph problem, the following features can be calculated:
.IP "\(bu" 4
Whether the reading groups form a genealogical pattern on the stemma.
.IP "\(bu" 4
The groupings, including lost/hypothetical witnesses if necessary, that minimize the amount of non-genealogical variation on the stemma.
.IP "\(bu" 4
The classes, which for each witness express whether (in a minimally non-genealogical case) the witness is a source of its reading, follows a parent witness, or reverts to an ancestral reading that is not the parent's.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
Creates a new graph problem. Requires two properties:
.IP "\(bu" 4
setlist \- An array of arrays expressing the witness sets. The inner
arrays will be converted to Set::Scalar objects, and must have distinct members.
.IP "\(bu" 4
graph \- A dot description of a graph (e.g. the output of a call to
Text::Tradition::Stemma::editable) against which the sets will be analyzed.
.PP
All other properties should be calculated by \s-1IDP\s0 rather than set manually.
These include:
.IP "\(bu" 4
is_genealogical \- Boolean, indicating whether the witness sets form
genealogical groupings on the graph.
.IP "\(bu" 4
status \- String to indicate whether a solution has been calculated
for this analysis problem. Recognized values are \*(L"\s-1OK\s0\*(R" (calculated) and
\&\*(L"running\*(R" (being calculated now). All other values, or no value, imply that
the calculation has yet to take place.
.IP "\(bu" 4
groupings \- These are extended (if necessary) versions of the witness
sets, which include the hypothetical witnesses necessary to minimize coincidence
of variation.
.IP "\(bu" 4
classes \- These are key/value pairs, keyed by witness, indicating for
each witness whether it is the source of a reading variant, whether it represents
a reversion to an ancestor (but not parent) reading, or whether its reading 
follows that of a parent on the graph.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$self\->has_class( $witness )"
.el .SS "\f(CW$self\fP\->has_class( \f(CW$witness\fP )"
.IX Subsection "$self->has_class( $witness )"
.ie n .SS "$self\->class( $witness )"
.el .SS "\f(CW$self\fP\->class( \f(CW$witness\fP )"
.IX Subsection "$self->class( $witness )"
If a class has been calculated for the given witness, has_class returns true
and class returns the calculated answer.
.ie n .SS "$self\->object_key"
.el .SS "\f(CW$self\fP\->object_key"
.IX Subsection "$self->object_key"
Returns a unique key that can be used to look up this graph/set combination in
a database. Currently an \s-1MD5\s0 hash of the request_string.
.ie n .SS "$self\->request_string"
.el .SS "\f(CW$self\fP\->request_string"
.IX Subsection "$self->request_string"
A request string is the graph followed by the groups, which should form a unique
key for the result.
.SS "by_size_and_alpha"
.IX Subsection "by_size_and_alpha"
A useful utility function to sort Set::Scalar objects first in descending 
order by size, then in ascending alphabetical order by first element (i.e. 
by stringification.)
.ie n .SS "$self\->sources"
.el .SS "\f(CW$self\fP\->sources"
.IX Subsection "$self->sources"
Return all 'source' class witnesses in these sets for this graph.
.ie n .SS "$self\->minimum_grouping_for( $set )"
.el .SS "\f(CW$self\fP\->minimum_grouping_for( \f(CW$set\fP )"
.IX Subsection "$self->minimum_grouping_for( $set )"
Return the minimum grouping (including necessary hypothetical witnesses) for
the witness set specified. Will return undef if \f(CW$set\fR does not match one of
the defined witness sets in \f(CW$self\fR\->sets.
.SH "CALCULATION STORAGE METHODS"
.IX Header "CALCULATION STORAGE METHODS"
.ie n .SS "$self\->is_genealogical( $bool )"
.el .SS "\f(CW$self\fP\->is_genealogical( \f(CW$bool\fP )"
.IX Subsection "$self->is_genealogical( $bool )"
Record that the sets are genealogical for this graph.
.ie n .SS "$self\->set_class( $witness, $class )"
.el .SS "\f(CW$self\fP\->set_class( \f(CW$witness\fP, \f(CW$class\fP )"
.IX Subsection "$self->set_class( $witness, $class )"
Record that the witness in question is of the given class.
.ie n .SS "$self\->record_grouping( $group )"
.el .SS "\f(CW$self\fP\->record_grouping( \f(CW$group\fP )"
.IX Subsection "$self->record_grouping( $group )"
Record that the group in question (either an arrayref or a Set::Scalar) forms
a minimum grouping on the graph. Will throw an error unless the group is a
(non-proper) superset of an existing witness set.
